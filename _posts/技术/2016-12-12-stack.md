---
layout: post
title: stack的实现
category: 科研
tags: algorithm 
keywords: 
description: 
---

```
#include"stack.h"

static void output_error(const char* error_type, const char* file_name, bool line) {
	printf("%s :%s%d\n", error_type, file_name, line);
}

bool stack_init(StackNode** stack) {
	if (*stack==NULL) {
		output_error("stack not NULL", __FILE__, __LINE__);
		return -1;
	}

        *stack = NULL;
	return 0;
}


bool stack_push(StackNode** stack, const void* val, size_t type_len) {
	StackNode *node = (StackNode*)malloc(sizeof(StackNode));

	if (node == NULL) {
		output_error("stack_push malloc error", __FILE__, __LINE__);
		return -1;
	}

	node->val = malloc(type_len);
	memcpy(node->val, val, type_len);
	node->next = *stack;
	*stack = node;

	return 0;
}

bool stack_top(const StackNode* stack, void* val, size_t type_len) {
	if (stack == NULL) {
		output_error("stackt_top error", __FILE__, __LINE__);
		return -1;
	} 		

	memcpy(val, stack->val, type_len);

	return 0;
}

bool stack_pop(StackNode** stack) {
	if (*stack == NULL) {
		output_error("stack_pop error", __FILE__, __LINE__);
		return -1;
	}
	StackNode *node;

	node = *stack;
	*stack = node->next;
	free(node->val);
	free(node);

	return 0;
}

bool stack_is_empty(const StackNode* stack) {
	return stack == NULL;
}

bool stack_destory(StackNode** stack) {
	StackNode *node = *stack, *q;

	while (node != NULL) {
		q = node;
		node = node->next;
		free(q->val);
		free(q);
	}
	
	*stack = NULL;

	return 0;
}

```



