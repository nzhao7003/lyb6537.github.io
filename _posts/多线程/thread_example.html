<h2 id="欢迎来到刘云宾的博客">欢迎来到刘云宾的博客</h2>
<h3 id="多线程的简单例子">多线程的简单例子</h3>
<h4 id="函数流程">函数流程</h4>
<p>主函数创建st_len个线程，每个线程将字符串st的指定索引所对应的字符打印COUNT次，通过条件变量和互斥锁使得打印出的顺序和指定的顺序相同。</p>
<h4 id="例如">例如</h4>
<h5 id="初始化">初始化</h5>
<ul>
<li>COUNT=10</li>
<li>FIRST_INDEX=1</li>
<li>st = &quot;ABC123&quot;;</li>
</ul>
<h5 id="输出">输出</h5>
<p>BC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123ABC123A</p>
<h4 id="linux下程序的编译与运行">linux下程序的编译与运行</h4>
<ul>
<li>$ make clean &amp;&amp; make</li>
<li>$ ./thread</li>
</ul>
<h4 id="完整项目"><a href="https://github.com/lyb6537/Thread">完整项目</a></h4>
<h4 id="代码详情">代码详情</h4>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define COUNT 10                               //打印的次数
#define FIRST_INDEX 1                          //起始索引      

static char*           st       = &quot;ABC123&quot;;    //打印的字符串
static int             st_len   = 0;           //字符串的长度以及线程的个数
static int         st_index = FIRST_INDEX; //字符串的索引

static pthread_mutex_t mutex;                  //互斥锁
static pthread_cond_t  cond;                   //条件变量

static void* thread(void*);                    //线程函数

int main(int argc, char** argv) {
    pthread_t* id;
    int i;

    st_len = strlen(st);
    id = (pthread_t*)malloc(sizeof(pthread_t)*st_len);
    if (id==NULL) {
        puts( &quot;pthread malloc error&quot; );
        return -1;
    }

    pthread_cond_init( &amp;cond,  NULL);  //条件变量初始化
    pthread_mutex_init(&amp;mutex, NULL);  //互斥锁初始化

    for (i = 0; i &lt; st_len; ++i) {
        pthread_create(id+i, NULL, thread, st+i);  //线程创建
    }

    for (i = 0; i &lt; st_len; ++i) {
        pthread_join(id[i], NULL);  //线程等待
    }

    puts(&quot;&quot;);   

    pthread_mutex_destroy(&amp;mutex); //互斥锁销毁
    pthread_cond_destroy( &amp;cond );  //条件变量销毁
    free(id);

    return 0;
}

//线程函数---打印指定的字符COUNT次
static void* thread(void* arg) {
    int k = (char*)arg - st;                 //该线程打印索引k，所对应的字符
    int i;

    for (i = 0; i &lt; COUNT; ++i) {
        pthread_mutex_lock(&amp;mutex); //互斥锁加锁
        while (st_index != k) {
            pthread_cond_wait(&amp;cond, &amp;mutex); //条件变量等待
        }
        st_index = ( st_index + 1 ) % st_len;     
        putchar(st[k]);
        pthread_cond_broadcast(&amp;cond); //条件变量广播
        pthread_mutex_unlock(&amp;mutex);  //互斥锁解锁
    }

    return NULL;
}</code></pre>
